'use strict';

var protobufTs = require('protobuf-ts');
var jsCommon = require('js-common');
var descriptor = require('protobuf-ts/protos/google/protobuf/descriptor');
var annotations = require('protobuf-ts/protos/google/api/annotations');
var _case = require('case');
var mongodb = require('mongodb');
var helpers = require('yargs/helpers');
var je = require('yargs');
var child_process = require('child_process');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var je__default = /*#__PURE__*/_interopDefault(je);

var ee=Object.defineProperty;var a=(r,e)=>ee(r,"name",{value:e,configurable:!0}),we=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+r+'" is not supported')});var Se=(r,e)=>{for(var t in e)ee(r,t,{get:e[t],enumerable:!0});};function A(r,e){if(!e)return r;if(!r)return e;for(let[t,s]of jsCommon.KV.entries(e))r[t]=s;return r}a(A,"setKV");function z(r,e,t){return r||(r={}),r[e]=t,r}a(z,"setKVone");var M=class{static{a(this,"Service");}name;id;client;scopes;host;transport;basePath;version;methods;headers;params;options;constructor(e,t,s,o){this.name=e.name,this.id=e.id,this.client=t,this.options={},e.scopes&&(this.scopes=e.scopes),e.basePath&&(this.basePath=e.basePath),e.version&&(this.version=e.version),this.methods=s,o?.credentials&&(this.options.credentials=o.credentials);let i=o?.headers,n=o?.params,{endpoint:d,transport:l}=this.selectTransport(e,o);if(this.host=d?.host,this.transport=l,i=A(i,d.headers),n=A(n,d.params),o?.clientOptions){let c=this.processClientOptions(o.clientOptions);i=A(i,c.headers),n=A(n,c.params),this.options=A(this.options,c.options);}this.headers=i,this.params=n;}selectTransport(e,t){let s,o;if(t?.host&&(s=e.endpoints.find(i=>i.host==t.host),!s))throw new jsCommon.InvalidArgumentError(`Service endpoint '${t.host}' does not exist`);if(t?.transport){if(!e.endpoints.length)throw new jsCommon.InvalidArgumentError(`Cannot set transport '${t.transport}' without an endpoint`);if(s){if(!s.transport.includes(t.transport))throw new jsCommon.InvalidArgumentError(`Transport '${t.transport}' not supported, options are: ${s.transport.join(", ")}`)}else if(s=e.endpoints.find(i=>i.transport.includes(t.transport)),!s)throw new jsCommon.InvalidArgumentError(`Transport '${t.transport}' not supported by any endpoint`);o=t.transport;}return s||(s=e.endpoints[0]),s&&!o&&(o=s.transport[0]),{endpoint:s,transport:o}}processClientOptions(e){let t,s,o;for(let i in e){if(!this.client.options||!(i in this.client.options))throw new jsCommon.InvalidArgumentError(`Client option '${i}' not found`);let n=this.client.options[i],d=e[i];if(n.enum&&!n.enum.includes(d))throw new jsCommon.InvalidArgumentError(`Client option '${i}' must be one of [${n.enum.join(", ")}], got '${d}'`);n.header?t=z(t,n.header,d):n.query?s=z(s,n.query,d):o=z(o,i,d);}return {headers:t,params:s,options:o}}};var E=class{static{a(this,"Client");}name;id;options;xssi;constructor(e){this.name=e.name,this.id=e.id,this.options=e.options,this.xssi=e.xssi;}request(e,t){throw new jsCommon.UnimplementedError}};function Re(r){let e={};return e[jsCommon.HttpContentType.PROTOBUF]={request:jsCommon.HttpContentType.PROTOBUF,response:jsCommon.HttpContentType.PROTOBUF,encode:t=>r.requestType.encode(t).finish(),decode:t=>r.responseType.decode(t)},e[jsCommon.HttpContentType.PROTOBUFFER]={request:jsCommon.HttpContentType.PROTOBUFFER,response:jsCommon.HttpContentType.PROTOBUFFER,encode:t=>r.requestType.encode(t).finish(),decode:t=>r.responseType.decode(t)},e[jsCommon.HttpContentType.JSON]={request:jsCommon.HttpContentType.JSON,response:jsCommon.HttpContentType.JSON,encode:t=>jsCommon.Json.encode(r.requestType.toJSON(t)),decode:t=>r.responseType.fromJSON(jsCommon.Json.decode(t))},e}a(Re,"transportFrom");var K=class{static{a(this,"ProtoServiceDefinition");}constructor(){}static methodsFrom(e){let t={};for(let s in e.methods){let o=e.methods[s],i=descriptor.MethodOptions.getExtension(o.options,annotations.http);if(!i)throw new jsCommon.UnsupportedError(`Service method ${o.name} has no 'httpRule'`);let n={name:o.name,scopes:[],transport:Re(o)};i.get?(n.method=jsCommon.HttpMethod.GET,n.path=i.get):i.put?(n.method=jsCommon.HttpMethod.PUT,n.path=i.put):i.post?(n.method=jsCommon.HttpMethod.POST,n.path=i.post):i.delete?(n.method=jsCommon.HttpMethod.DELETE,n.path=i.delete):i.patch?(n.method=jsCommon.HttpMethod.PATCH,n.path=i.patch):i.custom&&(n.method=i.custom.kind,n.path=i.custom.path),t[s]=n;}return t}};var I=class extends jsCommon.Request{static{a(this,"ApiRequest");}url;constructor(e){super(),this.url=new jsCommon.URLBuilder(e);}get https(){return this.url.scheme=="https"}execute(){return super.execute(this.url.href)}};function Ne(r,e){let t=`${r.id}->${e.name}`,s=e.path;return s.startsWith("/")&&(s=s.substring(1)),async function(o){if(!this.host)throw new jsCommon.InvalidArgumentError(`Service method '${t}' called without a host`);if(!this.transport)throw new jsCommon.InvalidArgumentError(`Service method '${t}' called without a transport`);if(!e.transport)throw new jsCommon.UnsupportedError(`Service method '${t}' has no transport`);let i=e.transport[this.transport];if(!i)throw new jsCommon.UnsupportedError(`Service method '${t}' has no transport '${this.transport}'`);let n=e.scopes;this.scopes&&(n?n=n.concat(this.scopes):n=this.scopes);let d=new I;d.url.setHost(this.host),d.setMethod(e.method),this.basePath&&d.url.addPath(this.basePath),this.version&&d.url.addPath(this.version),d.url.addPath(s),this.params&&d.url.setParams(this.params),d.setHeader(jsCommon.HttpHeader.CONTENT_TYPE,i.request??this.transport),this.headers&&d.setHeaders(this.headers);try{d.body=i.encode(o);}catch(c){throw c instanceof jsCommon.GenericError?c:new jsCommon.SerializeError(c)}let l=await this.client.request(d,this.options);if(i.response!==void 0){let c=l.headers.get(jsCommon.HttpHeader.CONTENT_TYPE);if(!c||c!==i.response&&!jsCommon.Mime.typeEquals(c,i.response))throw new jsCommon.ApiError(`Expected content type '${i.response}' but got '${c}'`)}try{return i.decode(l.body)}catch(c){throw c instanceof jsCommon.GenericError?c:new jsCommon.ParseError(c)}}}a(Ne,"createMethod");var $=class{static{a(this,"ServiceFactory");}static create(e,t){let s=class extends M{static{a(this,"GeneratedService");}},o=s.prototype;for(let[i,n]of jsCommon.KV.entries(t))o[i]=Ne(e,n);return s}};(class{static{a(this,"ServiceProvider");}clients;transports;services;constructor(){this.clients=new Map,this.transports=new Map,this.services=new Map;}methodsFrom(e){let t={};for(let s of e){let o=_case.camel(s.name),i={};for(let n of s.transport){let d=this.transports.get(n);d||(d=ae.from(n)),d&&(i[n]=d);}t[o]={name:s.name,scopes:s.scopes,path:s.path,method:s.method,body:s.body,transport:i};}return t}registerClients(e){for(let t of e){let s=t.implementation??E;delete t.implementation;let o=new s(t);this.clients.set(o.id,o);}}registerServices(e){for(let t of e){let s={};if(t.implementation){if(t.methods)throw new jsCommon.InvalidArgumentError("Service cannot have both 'implementation' and 'methods'");let o=t.implementation;s=K.methodsFrom(o),delete t.implementation;}else t.methods&&(s=this.methodsFrom(t.methods));this.services.set(t.id,{definition:t,methods:s,implementation:$.create(t,s)});}}registerTransports(e){for(let t of e)this.transports.set(t.id,t.implementation);}create(e,t){let s=this.services.get(e);if(!s)throw new jsCommon.NotFoundError(`Service '${e}' not found`);let o=this.clients.get(s.definition.client);if(!o)throw new jsCommon.NotFoundError(`Client '${s.definition.client}' not found`);return new s.implementation(s.definition,o,s.methods,t)}});var _={};Se(_,{AccessToken:()=>p,DatabaseStorageMedium:()=>U,DefaultOAuthProvider:()=>T,InvalidCredentialsError:()=>w,InvalidScopeError:()=>G,OAuthError:()=>m,OAuthIssuer:()=>j,OAuthProvider:()=>N,RefreshToken:()=>P,Scopes:()=>Ue,Storage:()=>pe,Store:()=>g,Token:()=>b,UnauthorizedClientError:()=>L,UnrecognizedIDClientError:()=>B,UserDeniedError:()=>J,launch:()=>Xe,login:()=>We});var Ue={parse(r){return r.split(" ")},stringify(r){return r.join(" ")}},m=class extends jsCommon.GenericError{static{a(this,"OAuthError");}constructor(e,t="Error authenticating with service"){super(e??"Generic OAuth error",t);}},w=class extends m{static{a(this,"InvalidCredentialsError");}constructor(e){super(e??"Invalid credentials");}},J=class extends m{static{a(this,"UserDeniedError");}constructor(e){super(e??"Authentication rejected by user");}},B=class extends m{static{a(this,"UnrecognizedIDClientError");}constructor(e){super(e??"Unrecognized client id");}},L=class extends m{static{a(this,"UnauthorizedClientError");}constructor(e){super(e??"Unauthorized client");}},G=class extends m{static{a(this,"InvalidScopeError");}constructor(e){super(e??"Invalid scope");}};var j=class{static{a(this,"OAuthIssuer");}name;id;constructor(e,t){this.name=e,this.id=t;}toString(e){return e.type?`${e.type} ${e.secret}`:e.secret}};var q=class{static{a(this,"Credentials");}};var b=class extends q{static{a(this,"Token");}id;issuer;expire;type;secret;metadata;constructor(e){super(),this.id=e.id,this.issuer=e.issuer,this.expire=e.expire,this.type=e.type,this.secret=e.secret,this.metadata=e.metadata;}get expired(){return this.expire===void 0?!1:Date.now()>this.expire*1e3}toString(){return this.issuer.toString(this)}},P=class extends b{static{a(this,"RefreshToken");}constructor(e){super(e);}},p=class extends b{static{a(this,"AccessToken");}client;scopes;refresher;refreshPromise;constructor(e){super(e),this.client=e.client,this.scopes=e.scopes,this.refresher=e.refresher;}assignToken(e){this.expire=e.expire,this.type=e.type,this.secret=e.secret,this.scopes=e.scopes,this.metadata=e.metadata;}async doRefresh(){if(!this.id)return this.assignToken(await this.issuer.refresh(this,this.refresher));await g.synchronized(this,async e=>{e&&e.secret!=this.secret?this.assignToken(e):this.assignToken(await this.issuer.refresh(this,this.refresher));});}refresh(){if(!this.refresher)throw new w("No refresh token");return this.refreshPromise||(this.refreshPromise=this.doRefresh(),this.refreshPromise.finally(()=>{this.refreshPromise=void 0;})),this.refreshPromise}revoke(){return this.issuer.revoke(this)}get meta(){return this.metadata??this.refresher?.metadata}};var N=class{static{a(this,"OAuthProvider");}issuers;clients;constructor(){this.issuers=new Map,this.clients=new Map;}registerIssuers(e){for(let t of e){let s=t.implementation,o=new s(t.name,t.id);this.issuers.set(o.id,o);}}registerClients(e){for(let t of e)this.clients.set(t.id,t);}getIssuer(e){let t=this.issuers.get(e);if(!t)throw new jsCommon.NotFoundError(`Issuer '${e}' not found`);return t}getClient(e){let t=this.clients.get(e);if(!t)throw new jsCommon.NotFoundError(`Client '${e}' not found`);return t}},T=new N;var V=class extends jsCommon.GenericError{static{a(this,"DatabaseError");}constructor(e){super(e,"Database error");}};function k(r){let e={id:r.id,issuer:r.issuer.id,type:r.type,secret:r.secret,expire:r.expire,metadata:r.metadata};return r instanceof p&&(e.client=r.client,e.scopes=r.scopes,e.refresher=r.refresher?.id),e}a(k,"tokenToJson");function le(r){return new P({id:r.id,issuer:T.getIssuer(r.issuer),type:r.type,secret:r.secret,expire:r.expire,metadata:r.metadata})}a(le,"createRefreshToken");function Y(r,e){return new p({id:r.id,issuer:T.getIssuer(r.issuer),type:r.type,secret:r.secret,expire:r.expire,metadata:r.metadata,client:r.client,scopes:r.scopes,refresher:e})}a(Y,"createAccessToken");var F=class{static{a(this,"StorageMedium");}},D=class extends F{static{a(this,"MemoryStorageMedium");}keys=new Map;refreshTokens=new Map;accessTokens=new Map;locks=new Map;setKey(e,t){this.keys.set(e,t);}getKey(e){return this.keys.get(e)}deleteKey(e){this.keys.delete(e);}addToken(e){e instanceof p?this.accessTokens.set(e.id,e):this.refreshTokens.set(e.id,e);}updateToken(e){}deleteToken(e){e instanceof p?this.accessTokens.delete(e.id):this.refreshTokens.delete(e.id);}getRefreshToken(e){return this.refreshTokens.get(e)}getAccessToken(e){return this.accessTokens.get(e)}async synchronized(e,t){let s=!1,o=new mongodb.ObjectId().toHexString(),i,n;for(let l=0;l<15&&(i=Date.now(),n=this.accessTokens.get(e.id),!(!n||n.secret!=e.secret));l++){let c=this.locks.get(e.id);if(!c||c.date<=i-2e4){c={id:o,date:i},this.locks.set(e.id,c),s=!0;break}await jsCommon.Promises.resolveAfter(2e3);}let d;try{await t(n);}catch(l){d=l;}if(s||!n){let l=this.locks.get(e.id),c=l?.id==o;(c||!l)&&(c&&this.locks.delete(e.id),this.accessTokens.set(e.id,e));}if(d)throw d}listAllKeys(){return this.keys}listAllRefreshTokens(){return Array.from(this.refreshTokens.values()).map(e=>k(e))}listAllAccessTokens(){return Array.from(this.accessTokens.values()).map(e=>k(e))}},U=class extends F{static{a(this,"DatabaseStorageMedium");}url;db;client;keys;refreshTokens;accessTokens;ready;shouldClose=!1;operations=0;closeTimeout;constructor(e,t){super(),this.url=e,this.db=t,this.closeTimeout=new jsCommon.Timer({initialTimeout:1e4},()=>this.destroy());}createIndex(e,t){let s=[];for(let[o,i]of jsCommon.KV.entries(t)){let n;typeof i=="object"&&(i.unique&&(n={unique:!0}),i=i.direction),s.push(e.createIndex({[o]:i},n));}return Promise.all(s)}async initialize(){this.client=new mongodb.MongoClient(this.url);try{await this.client.connect();}catch(t){throw this.close(),new jsCommon.UnavailableError(t)}let e=this.client.db(this.db);this.keys=e.collection("keys"),this.refreshTokens=e.collection("refreshTokens"),this.accessTokens=e.collection("accessTokens");try{await Promise.all([this.createIndex(this.keys,{key:{direction:1,unique:!0}}),this.createIndex(this.refreshTokens,{id:{direction:1,unique:!0}}),this.createIndex(this.accessTokens,{id:{direction:1,unique:!0},refresher:1})]);}catch(t){throw this.close(),new V(t)}this.closeTimeout.start();}close(){this.ready=void 0,this.shouldClose=!1,this.closeTimeout.stop(),this.client.close();}destroy(){this.operations?this.shouldClose=!0:this.close();}async setup(){return this.ready?(this.closeTimeout.start(),this.shouldClose=!1):this.ready=this.initialize(),this.ready}runDbOp(e){this.operations++;let t=this.setup().then(e).catch(s=>{throw new V(s)});return t.catch(s=>{console.error(`Database operation failed: ${s.stack??s.message}`);}).finally(()=>{this.operations--,!this.operations&&this.shouldClose&&this.close();}),t}setKey(e,t){return this.runDbOp(()=>this.keys.updateOne({key:e},{$set:{key:e,value:t}},{upsert:!0}))}getKey(e){return this.runDbOp(async()=>(await this.keys.findOne({key:e}))?.value)}deleteKey(e){return this.runDbOp(()=>this.keys.deleteOne({key:e}))}addToken(e){let t=k(e);return this.runDbOp(()=>(e instanceof p?this.accessTokens:this.refreshTokens).insertOne(t))}updateToken(e){let t=k(e);return this.runDbOp(()=>(e instanceof p?this.accessTokens:this.refreshTokens).updateOne({id:t.id},{$set:t}))}deleteToken(e){return this.runDbOp(()=>(e instanceof p?this.accessTokens:this.refreshTokens).deleteOne({id:e.id}))}getRefreshToken(e){return this.runDbOp(async()=>{let t=await this.refreshTokens.findOne({id:e});if(t)return le(t)})}getAccessToken(e){return this.runDbOp(async()=>{let t=await this.accessTokens.findOne({id:e});if(!t)return;let s;return t.refresher&&(s=await this.getRefreshToken(t.refresher)),Y(t,s)})}async synchronized(e,t){await this.setup();let s=!1,o=new mongodb.ObjectId,i,n;for(let l=0;l<15;l++){i=Date.now();try{if((await this.accessTokens.updateOne({id:e.id,secret:e.secret,$or:[{lockDate:{$lte:i-2e4}},{lockId:null}]},{$set:{lockId:o,lockDate:i}})).matchedCount){s=!0;break}let f=await this.accessTokens.findOne({id:e.id});if(!f||(n=Y(f),n.secret!=e.secret))break;await jsCommon.Promises.resolveAfter(2e3);}catch(c){console.error(`Failed to acquire lock: ${c.stack??c.message}`);break}}let d;try{await t(n);}catch(l){d=l;}if(s||!n){let l;s?l={lockId:o,lockDate:i}:l={lockId:null,lockDate:null};try{await this.accessTokens.updateOne({id:e.id,...l},{$set:{...k(e),lockDate:void 0,lockId:void 0}});}catch(c){console.error(`Failed to release lock: ${c.stack??c.message}`);}}if(d)throw d}listAllKeys(){return this.runDbOp(async()=>{let e=await this.keys.find().toArray(),t=new Map;for(let s of e)t.set(s.key,s.value);return t})}listAllRefreshTokens(){return this.runDbOp(()=>this.refreshTokens.find().toArray())}listAllAccessTokens(){return this.runDbOp(()=>this.accessTokens.find().toArray())}},Q=class extends D{static{a(this,"FileStorageMedium");}config;saving;queuedSave=!1;constructor(e){super();try{this.config=protobufTs.Config.loadConfigSync(e);}catch(s){if(!(s instanceof jsCommon.NotFoundError))throw s;this.config=new protobufTs.Config(e,{});}let t=this.config.get("keys");t&&(this.keys=jsCommon.KV.toMap(t)),this.loadTokens(this.refreshTokens,!0),this.loadTokens(this.accessTokens,!1);}loadTokens(e,t){let s=this.config.get(t?"refreshTokens":"accessTokens");if(s)for(let o of s){let i;o.refresher&&(i=this.refreshTokens.get(o.refresher));let n=t?le(o):Y(o,i);e.set(n.id,n);}}saveImpl(){let e=[],t=[];for(let[s,o]of this.refreshTokens)e.push(k(o));for(let[s,o]of this.accessTokens)t.push(k(o));return this.config.set("keys",jsCommon.KV.fromMap(this.keys)),this.config.set("refreshTokens",e),this.config.set("accessTokens",t),this.config.save()}async save(){if(this.saving){this.queuedSave=!0;return}do{this.queuedSave=!1,this.saving=this.saveImpl();try{await this.saving;}catch(e){console.error(`Failed to save credentials: ${e.stack??e.message}`);}}while(this.queuedSave);this.saving=void 0;}setKey(e,t){super.setKey(e,t),this.save();}getKey(e){return super.getKey(e)}deleteKey(e){super.deleteKey(e);}addToken(e){super.addToken(e),this.save();}updateToken(e){super.updateToken(e),this.save();}deleteToken(e){super.deleteToken(e),this.save();}getRefreshToken(e){return super.getRefreshToken(e)}getAccessToken(e){return super.getAccessToken(e)}},g=class{static{a(this,"Store");}static medium;constructor(){}static initialize(){if(this.medium)return;let e=protobufTs.Config.get("mongodb/url"),t=protobufTs.Config.get("credentials/database");if(e&&t){this.medium=new U(e,t);return}let s=protobufTs.Config.get("credentials/file");if(s){this.medium=new Q(s);return}console.warn("No database to store credentials, using memory"),this.medium=new D;}static setKey(e,t){return this.initialize(),this.medium.setKey(e,t)}static getKey(e){return this.initialize(),this.medium.getKey(e)}static deleteKey(e){return this.initialize(),this.medium.deleteKey(e)}static addToken(e){let t=(async()=>{if(this.initialize(),e.id)throw new jsCommon.ExistsError("Token already added");e.id=new mongodb.ObjectId().toHexString(),e instanceof p&&e.refresher&&!e.refresher.id&&await this.addToken(e.refresher),await this.medium.addToken(e);})();return t.catch(()=>{}),t}static updateToken(e){if(this.initialize(),!e.id)throw new jsCommon.NotFoundError("Token not added");return this.medium.updateToken(e)}static deleteToken(e){return (async()=>{if(this.initialize(),!e.id)throw new jsCommon.NotFoundError("Token not added");await this.medium.deleteToken(e),e.id=void 0;})()}static async getRefreshToken(e){this.initialize();let t=await this.medium.getRefreshToken(e);if(!t)throw new jsCommon.NotFoundError(`Refresh token with id '${e}' not found`);return t}static async getAccessToken(e){this.initialize();let t=await this.medium.getAccessToken(e);if(!t)throw new jsCommon.NotFoundError(`Access token with id '${e}' not found`);return t}static synchronized(e,t){if(!e.id)throw new jsCommon.NotFoundError("Token not added");return this.initialize(),this.medium.synchronized(e,t)}};async function We(){let r=je__default.default(helpers.hideBin(process.argv)).parseSync(),e=r._.join(" "),t=T.getClient(e),s=T.getIssuer(t.config.issuer),o=r.scope;typeof o=="string"&&(o=[o]),protobufTs.Config.use(r.config??"config.yaml"),delete r.$0,delete r._,delete r.scope,delete r.config;let i=await s.perform(t,o,r);return await g.addToken(i),i}a(We,"login");var Qe=we("electron");function Xe(r,e){let t=child_process.spawn(Qe,[r],{stdio:["ipc",process.stdin,process.stdout]}),s=[],o=!1,i=a(c=>{switch(c.event){case"ready":e&&t.send({event:"options",data:e}),t.send({event:"start"});break;case"output":s.push(c.data);break}},"message"),n=a(c=>{o=!0,t.killed||t.kill(c);},"signalHandler"),d=n.bind("SIGINT"),l=n.bind("SIGTERM");return process.on("SIGINT",d),process.on("SIGTERM",l),new Promise((c,f)=>{let h=a((y,x)=>{process.off("SIGINT",d),process.off("SIGTERM",l),!o&&(y===0?c(s):f(y!==null?new jsCommon.GenericError(`Child process exited with code ${y}`):new jsCommon.GenericError(`Child process exited with signal ${x}`)));},"close");t.on("message",i),t.on("close",h);})}a(Xe,"launch");var pe={};var ue={request:jsCommon.HttpContentType.OCTET_STREAM,response:jsCommon.HttpContentType.OCTET_STREAM,encode:r=>r,decode:r=>r};var ge={request:jsCommon.HttpContentType.JSON,response:jsCommon.HttpContentType.JSON,encode:r=>jsCommon.Json.encode(r),decode:r=>jsCommon.Json.decode(r)};var ve={request:jsCommon.HttpContentType.URLFORM,response:jsCommon.HttpContentType.URLFORM,encode:r=>jsCommon.URLParams.toString(r),decode:r=>jsCommon.URLParams.toKV(r.toString())};var ae={from(r){switch(r){case jsCommon.HttpContentType.JSON:return ge;case jsCommon.HttpContentType.URLFORM:return ve;case jsCommon.HttpContentType.OCTET_STREAM:return ue}}};(async function(){let r=je__default.default(helpers.hideBin(process.argv)).parseSync(),e=r._.join(" ")||"credentials.yaml";protobufTs.Config.use(r.config??"config.yaml");let t;try{t=protobufTs.Config.loadConfigSync(e);}catch(h){if(!(h instanceof jsCommon.NotFoundError))throw h;t=new protobufTs.Config(e,{});}let s=protobufTs.Config.get("mongodb/url"),o=protobufTs.Config.get("credentials/database");if(!s||!o)throw new jsCommon.InvalidArgumentError("No db to export from. Please set the mongodb/url and credentials/database keys in the config");let i=new _.DatabaseStorageMedium(s,o),n=await i.listAllKeys(),d=await i.listAllRefreshTokens(),l=await i.listAllAccessTokens();t.get("keys")||t.set("keys",{}),t.get("refreshTokens")||t.set("refreshTokens",[]),t.get("accessTokens")||t.set("accessTokens",[]);for(let[h,y]of n){let x=t.get("keys")[h];x!=y&&(x&&console.warn(`Overwriting existing value for ${h}: ${x} -> ${y}`),t.get("keys")[h]=y);}let c=new Map;for(let h of t.get("refreshTokens"))c.set(h.id,{...h,_id:void 0});for(let h of d)c.set(h.id,{...h,_id:void 0});t.set("refreshTokens",Array.from(c.values()));let f=new Map;for(let h of t.get("accessTokens"))f.set(h.id,{...h,_id:void 0});for(let h of l)f.set(h.id,{...h,_id:void 0});t.set("accessTokens",Array.from(f.values())),console.log(`Exported ${n.size} keys and ${d.length+l.length} tokens`),i.destroy(),await t.save();})();
