'use strict';

var protobufTs = require('protobuf-ts');
var jsCommon = require('js-common');
var descriptor = require('protobuf-ts/protos/google/protobuf/descriptor');
var annotations = require('protobuf-ts/protos/google/api/annotations');
var _case = require('case');
var mongodb = require('mongodb');
var helpers = require('yargs/helpers');
var Ge = require('yargs');
var child_process = require('child_process');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var Ge__default = /*#__PURE__*/_interopDefault(Ge);

var X=Object.defineProperty;var a=(r,e)=>X(r,"name",{value:e,configurable:!0}),we=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+r+'" is not supported')});var Se=(r,e)=>{for(var t in e)X(r,t,{get:e[t],enumerable:!0});};function w(r,e){if(!e)return r;if(!r)return e;for(let[t,s]of jsCommon.KV.entries(e))r[t]=s;return r}a(w,"setKV");function U(r,e,t){return r||(r={}),r[e]=t,r}a(U,"setKVone");var P=class{static{a(this,"Service");}name;id;client;scopes;host;transport;basePath;version;methods;headers;params;options;constructor(e,t,s,n){this.name=e.name,this.id=e.id,this.client=t,this.options={},e.scopes&&(this.scopes=e.scopes),e.basePath&&(this.basePath=e.basePath),e.version&&(this.version=e.version),this.methods=s,n?.credentials&&(this.options.credentials=n.credentials);let i=n?.headers,o=n?.params,{endpoint:d,transport:l}=this.selectTransport(e,n);if(this.host=d?.host,this.transport=l,i=w(i,d.headers),o=w(o,d.params),n?.clientOptions){let c=this.processClientOptions(n.clientOptions);i=w(i,c.headers),o=w(o,c.params),this.options=w(this.options,c.options);}this.headers=i,this.params=o;}selectTransport(e,t){let s,n;if(t?.host&&(s=e.endpoints.find(i=>i.host==t.host),!s))throw new jsCommon.InvalidArgumentError(`Service endpoint '${t.host}' does not exist`);if(t?.transport){if(!e.endpoints.length)throw new jsCommon.InvalidArgumentError(`Cannot set transport '${t.transport}' without an endpoint`);if(s){if(!s.transport.includes(t.transport))throw new jsCommon.InvalidArgumentError(`Transport '${t.transport}' not supported, options are: ${s.transport.join(", ")}`)}else if(s=e.endpoints.find(i=>i.transport.includes(t.transport)),!s)throw new jsCommon.InvalidArgumentError(`Transport '${t.transport}' not supported by any endpoint`);n=t.transport;}return s||(s=e.endpoints[0]),s&&!n&&(n=s.transport[0]),{endpoint:s,transport:n}}processClientOptions(e){let t,s,n;for(let i in e){if(!this.client.options||!(i in this.client.options))throw new jsCommon.InvalidArgumentError(`Client option '${i}' not found`);let o=this.client.options[i],d=e[i];if(o.enum&&!o.enum.includes(d))throw new jsCommon.InvalidArgumentError(`Client option '${i}' must be one of [${o.enum.join(", ")}], got '${d}'`);o.header?t=U(t,o.header,d):o.query?s=U(s,o.query,d):n=U(n,i,d);}return {headers:t,params:s,options:n}}};var R=class{static{a(this,"Client");}name;id;options;xssi;constructor(e){this.name=e.name,this.id=e.id,this.options=e.options,this.xssi=e.xssi;}request(e,t){throw new jsCommon.UnimplementedError}};function Re(r){let e={};return e[jsCommon.HttpContentType.PROTOBUF]={request:jsCommon.HttpContentType.PROTOBUF,response:jsCommon.HttpContentType.PROTOBUF,encode:t=>r.requestType.encode(t).finish(),decode:t=>r.responseType.decode(t)},e[jsCommon.HttpContentType.PROTOBUFFER]={request:jsCommon.HttpContentType.PROTOBUFFER,response:jsCommon.HttpContentType.PROTOBUFFER,encode:t=>r.requestType.encode(t).finish(),decode:t=>r.responseType.decode(t)},e[jsCommon.HttpContentType.JSON]={request:jsCommon.HttpContentType.JSON,response:jsCommon.HttpContentType.JSON,encode:t=>jsCommon.Json.encode(r.requestType.toJSON(t)),decode:t=>r.responseType.fromJSON(jsCommon.Json.decode(t))},e}a(Re,"transportFrom");var C=class{static{a(this,"ProtoServiceDefinition");}constructor(){}static methodsFrom(e){let t={};for(let s in e.methods){let n=e.methods[s],i=descriptor.MethodOptions.getExtension(n.options,annotations.http);if(!i)throw new jsCommon.UnsupportedError(`Service method ${n.name} has no 'httpRule'`);let o={name:n.name,scopes:[],transport:Re(n)};i.get?(o.method=jsCommon.HttpMethod.GET,o.path=i.get):i.put?(o.method=jsCommon.HttpMethod.PUT,o.path=i.put):i.post?(o.method=jsCommon.HttpMethod.POST,o.path=i.post):i.delete?(o.method=jsCommon.HttpMethod.DELETE,o.path=i.delete):i.patch?(o.method=jsCommon.HttpMethod.PATCH,o.path=i.patch):i.custom&&(o.method=i.custom.kind,o.path=i.custom.path),t[s]=o;}return t}};var K=class extends jsCommon.Request{static{a(this,"ApiRequest");}url;constructor(e){super(),this.url=new jsCommon.URLBuilder(e);}get https(){return this.url.scheme=="https"}execute(){return super.execute(this.url.href)}};function Ve(r,e){let t=`${r.id}->${e.name}`,s=e.path;return s.startsWith("/")&&(s=s.substring(1)),async function(n){if(!this.host)throw new jsCommon.InvalidArgumentError(`Service method '${t}' called without a host`);if(!this.transport)throw new jsCommon.InvalidArgumentError(`Service method '${t}' called without a transport`);if(!e.transport)throw new jsCommon.UnsupportedError(`Service method '${t}' has no transport`);let i=e.transport[this.transport];if(!i)throw new jsCommon.UnsupportedError(`Service method '${t}' has no transport '${this.transport}'`);let o=e.scopes;this.scopes&&(o?o=o.concat(this.scopes):o=this.scopes);let d=new K;d.url.setHost(this.host),d.setMethod(e.method),this.basePath&&d.url.addPath(this.basePath),this.version&&d.url.addPath(this.version),d.url.addPath(s),this.params&&d.url.setParams(this.params),d.setHeader(jsCommon.HttpHeader.CONTENT_TYPE,i.request??this.transport),this.headers&&d.setHeaders(this.headers);try{d.body=i.encode(n);}catch(c){throw c instanceof jsCommon.GenericError?c:new jsCommon.SerializeError(c)}let l=await this.client.request(d,this.options);if(i.response!==void 0){let c=l.headers.get(jsCommon.HttpHeader.CONTENT_TYPE);if(!c||c!==i.response&&!jsCommon.Mime.typeEquals(c,i.response))throw new jsCommon.ApiError(`Expected content type '${i.response}' but got '${c}'`)}try{return i.decode(l.body)}catch(c){throw c instanceof jsCommon.GenericError?c:new jsCommon.ParseError(c)}}}a(Ve,"createMethod");var M=class{static{a(this,"ServiceFactory");}static create(e,t){let s=class extends P{static{a(this,"GeneratedService");}},n=s.prototype;for(let[i,o]of jsCommon.KV.entries(t))n[i]=Ve(e,o);return s}};(class{static{a(this,"ServiceProvider");}clients;transports;services;constructor(){this.clients=new Map,this.transports=new Map,this.services=new Map;}methodsFrom(e){let t={};for(let s of e){let n=_case.camel(s.name),i={};for(let o of s.transport){let d=this.transports.get(o);d||(d=ne.from(o)),d&&(i[o]=d);}t[n]={name:s.name,scopes:s.scopes,path:s.path,method:s.method,body:s.body,transport:i};}return t}registerClients(e){for(let t of e){let s=t.implementation??R;delete t.implementation;let n=new s(t);this.clients.set(n.id,n);}}registerServices(e){for(let t of e){let s={};if(t.implementation){if(t.methods)throw new jsCommon.InvalidArgumentError("Service cannot have both 'implementation' and 'methods'");let n=t.implementation;s=C.methodsFrom(n),delete t.implementation;}else t.methods&&(s=this.methodsFrom(t.methods));this.services.set(t.id,{definition:t,methods:s,implementation:M.create(t,s)});}}registerTransports(e){for(let t of e)this.transports.set(t.id,t.implementation);}create(e,t){let s=this.services.get(e);if(!s)throw new jsCommon.NotFoundError(`Service '${e}' not found`);let n=this.clients.get(s.definition.client);if(!n)throw new jsCommon.NotFoundError(`Client '${s.definition.client}' not found`);return new s.implementation(s.definition,n,s.methods,t)}});var N={};Se(N,{AccessToken:()=>h,DatabaseStorageMedium:()=>V,DefaultOAuthProvider:()=>y,InvalidCredentialsError:()=>k,InvalidScopeError:()=>B,OAuthError:()=>f,OAuthIssuer:()=>L,OAuthProvider:()=>I,RefreshToken:()=>O,Scopes:()=>Ue,Storage:()=>le,Store:()=>m,Token:()=>x,UnauthorizedClientError:()=>_,UnrecognizedIDClientError:()=>J,UserDeniedError:()=>H,launch:()=>Qe,login:()=>je});var Ue={parse(r){return r.split(" ")},stringify(r){return r.join(" ")}},f=class extends jsCommon.GenericError{static{a(this,"OAuthError");}constructor(e,t="Error authenticating with service"){super(e??"Generic OAuth error",t);}},k=class extends f{static{a(this,"InvalidCredentialsError");}constructor(e){super(e??"Invalid credentials");}},H=class extends f{static{a(this,"UserDeniedError");}constructor(e){super(e??"Authentication rejected by user");}},J=class extends f{static{a(this,"UnrecognizedIDClientError");}constructor(e){super(e??"Unrecognized client id");}},_=class extends f{static{a(this,"UnauthorizedClientError");}constructor(e){super(e??"Unauthorized client");}},B=class extends f{static{a(this,"InvalidScopeError");}constructor(e){super(e??"Invalid scope");}};var L=class{static{a(this,"OAuthIssuer");}name;id;constructor(e,t){this.name=e,this.id=t;}toString(e){return e.type?`${e.type} ${e.secret}`:e.secret}};var E=class{static{a(this,"Credentials");}};var x=class extends E{static{a(this,"Token");}id;issuer;expire;type;secret;metadata;constructor(e){super(),this.id=e.id,this.issuer=e.issuer,this.expire=e.expire,this.type=e.type,this.secret=e.secret,this.metadata=e.metadata;}get expired(){return this.expire===void 0?!1:Date.now()>this.expire*1e3}toString(){return this.issuer.toString(this)}},O=class extends x{static{a(this,"RefreshToken");}constructor(e){super(e);}},h=class extends x{static{a(this,"AccessToken");}client;scopes;refresher;refreshPromise;constructor(e){super(e),this.client=e.client,this.scopes=e.scopes,this.refresher=e.refresher;}assignToken(e){this.expire=e.expire,this.type=e.type,this.secret=e.secret,this.scopes=e.scopes,this.metadata=e.metadata;}async doRefresh(){if(!this.id)return this.assignToken(await this.issuer.refresh(this,this.refresher));await m.synchronized(this,async e=>{e&&e.secret!=this.secret?this.assignToken(e):this.assignToken(await this.issuer.refresh(this,this.refresher));});}refresh(){if(!this.refresher)throw new k("No refresh token");return this.refreshPromise||(this.refreshPromise=this.doRefresh(),this.refreshPromise.finally(()=>{this.refreshPromise=void 0;})),this.refreshPromise}revoke(){return this.issuer.revoke(this)}get meta(){return this.metadata??this.refresher?.metadata}};var I=class{static{a(this,"OAuthProvider");}issuers;clients;constructor(){this.issuers=new Map,this.clients=new Map;}registerIssuers(e){for(let t of e){let s=t.implementation,n=new s(t.name,t.id);this.issuers.set(n.id,n);}}registerClients(e){for(let t of e)this.clients.set(t.id,t);}getIssuer(e){let t=this.issuers.get(e);if(!t)throw new jsCommon.NotFoundError(`Issuer '${e}' not found`);return t}getClient(e){let t=this.clients.get(e);if(!t)throw new jsCommon.NotFoundError(`Client '${e}' not found`);return t}},y=new I;var A=class extends jsCommon.GenericError{static{a(this,"DatabaseError");}constructor(e){super(e,"Database error");}};function g(r){let e={id:r.id,issuer:r.issuer.id,type:r.type,secret:r.secret,expire:r.expire,metadata:r.metadata};return r instanceof h&&(e.client=r.client,e.scopes=r.scopes,e.refresher=r.refresher?.id),e}a(g,"tokenToJson");function ce(r){return new O({id:r.id,issuer:y.getIssuer(r.issuer),type:r.type,secret:r.secret,expire:r.expire,metadata:r.metadata})}a(ce,"createRefreshToken");function j(r,e){return new h({id:r.id,issuer:y.getIssuer(r.issuer),type:r.type,secret:r.secret,expire:r.expire,metadata:r.metadata,client:r.client,scopes:r.scopes,refresher:e})}a(j,"createAccessToken");var $=class{static{a(this,"StorageMedium");}},q=class extends ${static{a(this,"MemoryStorageMedium");}keys=new Map;refreshTokens=new Map;accessTokens=new Map;locks=new Map;setKey(e,t){this.keys.set(e,t);}getKey(e){return this.keys.get(e)}deleteKey(e){this.keys.delete(e);}addToken(e){e instanceof h?this.accessTokens.set(e.id,e):this.refreshTokens.set(e.id,e);}updateToken(e){}deleteToken(e){e instanceof h?this.accessTokens.delete(e.id):this.refreshTokens.delete(e.id);}getRefreshToken(e){return this.refreshTokens.get(e)}getAccessToken(e){return this.accessTokens.get(e)}async synchronized(e,t){let s=!1,n=new mongodb.ObjectId().toHexString(),i,o;for(let l=0;l<15&&(i=Date.now(),o=this.accessTokens.get(e.id),!(!o||o.secret!=e.secret));l++){let c=this.locks.get(e.id);if(!c||c.date<=i-2e4){c={id:n,date:i},this.locks.set(e.id,c),s=!0;break}await jsCommon.Promises.resolveAfter(2e3);}let d;try{await t(o);}catch(l){d=l;}if(s||!o){let l=this.locks.get(e.id),c=l?.id==n;(c||!l)&&(c&&this.locks.delete(e.id),this.accessTokens.set(e.id,e));}if(d)throw d}listAllKeys(){return this.keys}listAllRefreshTokens(){return Array.from(this.refreshTokens.values()).map(e=>g(e))}listAllAccessTokens(){return Array.from(this.accessTokens.values()).map(e=>g(e))}},V=class extends ${static{a(this,"DatabaseStorageMedium");}url;db;client;keys;refreshTokens;accessTokens;ready;shouldClose=!1;operations=0;closeTimeout;constructor(e,t){super(),this.url=e,this.db=t,this.closeTimeout=new jsCommon.Timer({initialTimeout:1e4},()=>this.destroy());}createIndex(e,t){let s=[];for(let[n,i]of jsCommon.KV.entries(t)){let o;typeof i=="object"&&(i.unique&&(o={unique:!0}),i=i.direction),s.push(e.createIndex({[n]:i},o));}return Promise.all(s)}async initialize(){this.client=new mongodb.MongoClient(this.url);try{await this.client.connect();}catch(t){throw new A(t)}let e=this.client.db(this.db);this.keys=e.collection("keys"),this.refreshTokens=e.collection("refreshTokens"),this.accessTokens=e.collection("accessTokens");try{await Promise.all([this.createIndex(this.keys,{key:{direction:1,unique:!0}}),this.createIndex(this.refreshTokens,{id:{direction:1,unique:!0}}),this.createIndex(this.accessTokens,{id:{direction:1,unique:!0},refresher:1})]);}catch(t){throw this.client.close(),new A(t)}this.closeTimeout.start();}close(){this.ready=void 0,this.shouldClose=!1,this.closeTimeout.stop(),this.client.close();}destroy(){this.operations?this.shouldClose=!0:this.close();}async setup(){return this.ready?(this.closeTimeout.start(),this.shouldClose=!1):this.ready=this.initialize(),this.ready}runDbOp(e){this.operations++;let t=this.setup().then(e).catch(s=>{throw new A(s)});return t.catch(s=>{console.error(`Database operation failed: ${s.stack??s.message}`);}).finally(()=>{this.operations--,!this.operations&&this.shouldClose&&this.close();}),t}setKey(e,t){return this.runDbOp(()=>this.keys.updateOne({key:e},{$set:{key:e,value:t}},{upsert:!0}))}getKey(e){return this.runDbOp(async()=>(await this.keys.findOne({key:e}))?.value)}deleteKey(e){return this.runDbOp(()=>this.keys.deleteOne({key:e}))}addToken(e){let t=g(e);return this.runDbOp(()=>(e instanceof h?this.accessTokens:this.refreshTokens).insertOne(t))}updateToken(e){let t=g(e);return this.runDbOp(()=>(e instanceof h?this.accessTokens:this.refreshTokens).updateOne({id:t.id},{$set:t}))}deleteToken(e){return this.runDbOp(()=>(e instanceof h?this.accessTokens:this.refreshTokens).deleteOne({id:e.id}))}getRefreshToken(e){return this.runDbOp(async()=>{let t=await this.refreshTokens.findOne({id:e});if(t)return ce(t)})}getAccessToken(e){return this.runDbOp(async()=>{let t=await this.accessTokens.findOne({id:e});if(!t)return;let s;return t.refresher&&(s=await this.getRefreshToken(t.refresher)),j(t,s)})}async synchronized(e,t){await this.setup();let s=!1,n=new mongodb.ObjectId,i,o;for(let l=0;l<15;l++){i=Date.now();try{if((await this.accessTokens.updateOne({id:e.id,secret:e.secret,$or:[{lockDate:{$lte:i-2e4}},{lockId:null}]},{$set:{lockId:n,lockDate:i}})).matchedCount){s=!0;break}let p=await this.accessTokens.findOne({id:e.id});if(!p||(o=j(p),o.secret!=e.secret))break;await jsCommon.Promises.resolveAfter(2e3);}catch(c){console.error(`Failed to acquire lock: ${c.stack??c.message}`);break}}let d;try{await t(o);}catch(l){d=l;}if(s||!o){let l;s?l={lockId:n,lockDate:i}:l={lockId:null,lockDate:null};try{await this.accessTokens.updateOne({id:e.id,...l},{$set:{...g(e),lockDate:void 0,lockId:void 0}});}catch(c){console.error(`Failed to release lock: ${c.stack??c.message}`);}}if(d)throw d}listAllKeys(){return this.runDbOp(async()=>{let e=await this.keys.find().toArray(),t=new Map;for(let s of e)t.set(s.key,s.value);return t})}listAllRefreshTokens(){return this.runDbOp(()=>this.refreshTokens.find().toArray())}listAllAccessTokens(){return this.runDbOp(()=>this.accessTokens.find().toArray())}},W=class extends q{static{a(this,"FileStorageMedium");}config;saving;queuedSave=!1;constructor(e){super();try{this.config=protobufTs.Config.loadConfigSync(e);}catch(s){if(!(s instanceof jsCommon.NotFoundError))throw s;this.config=new protobufTs.Config(e,{});}let t=this.config.get("keys");t&&(this.keys=jsCommon.KV.toMap(t)),this.loadTokens(this.refreshTokens,!0),this.loadTokens(this.accessTokens,!1);}loadTokens(e,t){let s=this.config.get(t?"refreshTokens":"accessTokens");if(s)for(let n of s){let i;n.refresher&&(i=this.refreshTokens.get(n.refresher));let o=t?ce(n):j(n,i);e.set(o.id,o);}}saveImpl(){let e=[],t=[];for(let[s,n]of this.refreshTokens)e.push(g(n));for(let[s,n]of this.accessTokens)t.push(g(n));return this.config.set("keys",jsCommon.KV.fromMap(this.keys)),this.config.set("refreshTokens",e),this.config.set("accessTokens",t),this.config.save()}async save(){if(this.saving){this.queuedSave=!0;return}do{this.queuedSave=!1,this.saving=this.saveImpl();try{await this.saving;}catch(e){console.error(`Failed to save credentials: ${e.stack??e.message}`);}}while(this.queuedSave);this.saving=void 0;}setKey(e,t){super.setKey(e,t),this.save();}getKey(e){return super.getKey(e)}deleteKey(e){super.deleteKey(e);}addToken(e){super.addToken(e),this.save();}updateToken(e){super.updateToken(e),this.save();}deleteToken(e){super.deleteToken(e),this.save();}getRefreshToken(e){return super.getRefreshToken(e)}getAccessToken(e){return super.getAccessToken(e)}},m=class{static{a(this,"Store");}static medium;constructor(){}static initialize(){if(this.medium)return;let e=protobufTs.Config.get("mongodb/url"),t=protobufTs.Config.get("credentials/database");if(e&&t){this.medium=new V(e,t);return}let s=protobufTs.Config.get("credentials/file");if(s){this.medium=new W(s);return}console.warn("No database to store credentials, using memory"),this.medium=new q;}static async setKey(e,t){this.initialize(),await this.medium.setKey(e,t);}static async getKey(e){return this.initialize(),await this.medium.getKey(e)}static async deleteKey(e){this.initialize(),await this.medium.deleteKey(e);}static async addToken(e){if(this.initialize(),e.id)throw new jsCommon.ExistsError("Token already added");e.id=new mongodb.ObjectId().toHexString(),e instanceof h&&e.refresher&&!e.refresher.id&&await this.addToken(e.refresher),await this.medium.addToken(e);}static async updateToken(e){if(this.initialize(),!e.id)throw new jsCommon.NotFoundError("Token not added");await this.medium.updateToken(e);}static async deleteToken(e){if(this.initialize(),!e.id)throw new jsCommon.NotFoundError("Token not added");await this.medium.deleteToken(e),e.id=void 0;}static async getRefreshToken(e){this.initialize();let t=await this.medium.getRefreshToken(e);if(!t)throw new jsCommon.NotFoundError(`Refresh token with id '${e}' not found`);return t}static async getAccessToken(e){this.initialize();let t=await this.medium.getAccessToken(e);if(!t)throw new jsCommon.NotFoundError(`Access token with id '${e}' not found`);return t}static synchronized(e,t){if(!e.id)throw new jsCommon.NotFoundError("Token not added");return this.initialize(),this.medium.synchronized(e,t)}};async function je(){let r=Ge__default.default(helpers.hideBin(process.argv)).parseSync(),e=r._.join(" "),t=y.getClient(e),s=y.getIssuer(t.config.issuer),n=r.scope;typeof n=="string"&&(n=[n]),protobufTs.Config.use(r.config??"config.yaml"),delete r.$0,delete r._,delete r.scope,delete r.config;let i=await s.perform(t,n,r);return await m.addToken(i),i}a(je,"login");var Ye=we("electron");function Qe(r,e){let t=child_process.spawn(Ye,[r],{stdio:["ipc",process.stdin,process.stdout]}),s=[],n=!1,i=a(c=>{switch(c.event){case"ready":e&&t.send({event:"options",data:e}),t.send({event:"start"});break;case"output":s.push(c.data);break}},"message"),o=a(c=>{n=!0,t.killed||t.kill(c);},"signalHandler"),d=o.bind("SIGINT"),l=o.bind("SIGTERM");return process.on("SIGINT",d),process.on("SIGTERM",l),new Promise((c,p)=>{let ke=a((D,ve)=>{process.off("SIGINT",d),process.off("SIGTERM",l),!n&&(D===0?c(s):p(D!==null?new jsCommon.GenericError(`Child process exited with code ${D}`):new jsCommon.GenericError(`Child process exited with signal ${ve}`)));},"close");t.on("message",i),t.on("close",ke);})}a(Qe,"launch");var le={};var pe={request:jsCommon.HttpContentType.OCTET_STREAM,response:jsCommon.HttpContentType.OCTET_STREAM,encode:r=>r,decode:r=>r};var me={request:jsCommon.HttpContentType.JSON,response:jsCommon.HttpContentType.JSON,encode:r=>jsCommon.Json.encode(r),decode:r=>jsCommon.Json.decode(r)};var Te={request:jsCommon.HttpContentType.URLFORM,response:jsCommon.HttpContentType.URLFORM,encode:r=>jsCommon.URLParams.toString(r),decode:r=>jsCommon.URLParams.toKV(r.toString())};var ne={from(r){switch(r){case jsCommon.HttpContentType.JSON:return me;case jsCommon.HttpContentType.URLFORM:return Te;case jsCommon.HttpContentType.OCTET_STREAM:return pe}}};(async function(){let r=Ge__default.default(helpers.hideBin(process.argv)).parseSync(),e=r._.join(" ")||"credentials.yaml";protobufTs.Config.use(r.config??"config.yaml");let t=protobufTs.Config.loadConfigSync(e),s=protobufTs.Config.get("mongodb/url"),n=protobufTs.Config.get("credentials/database");if(!s||!n)throw new jsCommon.InvalidArgumentError("No db to import to. Please set the mongodb/url and credentials/database keys in the config");let i=new N.DatabaseStorageMedium(s,n);await i.setup();let o=0;for(let[l,c]of jsCommon.KV.entries(t.get("keys"))){let p=await i.keys.findOne({key:l});o++,p?.value!=c&&(p&&console.warn(`Overwriting existing value for ${l}: ${p.value} -> ${c}`),await i.keys.updateOne({key:l},{$set:{key:l,value:c}},{upsert:!0}));}let d=0;for(let l of t.get("refreshTokens"))await i.refreshTokens.updateOne({id:l.id},{$set:l},{upsert:!0}),d++;for(let l of t.get("accessTokens"))await i.accessTokens.updateOne({id:l.id},{$set:l},{upsert:!0}),d++;console.log(`Imported ${o} keys and ${d} tokens`),i.destroy();})();
