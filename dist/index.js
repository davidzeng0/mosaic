'use strict';

var jsCommon = require('js-common');
var descriptor = require('protobuf-ts/protos/google/protobuf/descriptor');
var annotations = require('protobuf-ts/protos/google/api/annotations');
var _case = require('case');
var mongodb = require('mongodb');
var child_process = require('child_process');
var helpers = require('yargs/helpers');
var je = require('yargs');
var promises = require('fs/promises');
var fs = require('fs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var je__default = /*#__PURE__*/_interopDefault(je);

var xe=Object.defineProperty;var a=(s,e)=>xe(s,"name",{value:e,configurable:!0}),Oe=(s=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(s,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):s)(function(s){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+s+'" is not supported')});function S(s,e){if(!e)return s;if(!s)return e;for(let[t,r]of jsCommon.KV.entries(e))s[t]=r;return s}a(S,"setKV");function q(s,e,t){return s||(s={}),s[e]=t,s}a(q,"setKVone");var A=class{static{a(this,"Service");}name;id;client;scopes;host;transport;basePath;version;methods;headers;params;options;constructor(e,t,r,i){this.name=e.name,this.id=e.id,this.client=t,this.options={},e.scopes&&(this.scopes=e.scopes),e.basePath&&(this.basePath=e.basePath),e.version&&(this.version=e.version),this.methods=r,i?.credentials&&(this.options.credentials=i.credentials);let n=i?.headers,o=i?.params,{endpoint:d,transport:c}=this.selectTransport(e,i);if(this.host=d?.host,this.transport=c,n=S(n,d.headers),o=S(o,d.params),i?.clientOptions){let l=this.processClientOptions(i.clientOptions);n=S(n,l.headers),o=S(o,l.params),this.options=S(this.options,l.options);}this.headers=n,this.params=o;}selectTransport(e,t){let r,i;if(t?.host&&(r=e.endpoints.find(n=>n.host==t.host),!r))throw new jsCommon.InvalidArgumentError(`Service endpoint '${t.host}' does not exist`);if(t?.transport){if(!e.endpoints.length)throw new jsCommon.InvalidArgumentError(`Cannot set transport '${t.transport}' without an endpoint`);if(r){if(!r.transport.includes(t.transport))throw new jsCommon.InvalidArgumentError(`Transport '${t.transport}' not supported, options are: ${r.transport.join(", ")}`)}else if(r=e.endpoints.find(n=>n.transport.includes(t.transport)),!r)throw new jsCommon.InvalidArgumentError(`Transport '${t.transport}' not supported by any endpoint`);i=t.transport;}return r||(r=e.endpoints[0]),r&&!i&&(i=r.transport[0]),{endpoint:r,transport:i}}processClientOptions(e){let t,r,i;for(let n in e){if(!this.client.options||!(n in this.client.options))throw new jsCommon.InvalidArgumentError(`Client option '${n}' not found`);let o=this.client.options[n],d=e[n];if(o.enum&&!o.enum.includes(d))throw new jsCommon.InvalidArgumentError(`Client option '${n}' must be one of [${o.enum.join(", ")}], got '${d}'`);o.header?t=q(t,o.header,d):o.query?r=q(r,o.query,d):i=q(i,n,d);}return {headers:t,params:r,options:i}}preflight(){if(!this.host)throw new jsCommon.InvalidArgumentError(`Service '${this}' cannot be used without a valid host`);if(!this.transport)throw new jsCommon.InvalidArgumentError(`Service '${this}' cannot be used without a valid transport`)}getFullPath(e){let t=[];return this.basePath&&t.push(this.basePath),this.version&&t.push(this.version),t.push(e),t.join("/")}async transact(e,t,r,i,n){let o=new P;o.setMethod(e),o.url.setHost(this.host),o.url.setPath(t),this.params&&o.url.setParams(this.params),o.setHeader(jsCommon.HttpHeader.CONTENT_TYPE,i),this.headers&&o.setHeaders(this.headers);try{o.body=r.encode(n);}catch(c){throw c instanceof jsCommon.GenericError?c:new jsCommon.SerializeError(c)}let d=await this.client.request(o,this.options);if(r.response!==void 0){let c=d.headers.get(jsCommon.HttpHeader.CONTENT_TYPE);if(!c||c!==r.response&&!jsCommon.Mime.typeEquals(c,r.response))throw new jsCommon.ApiError(`Expected content type '${r.response}' but got '${c}'`)}try{return r.decode(d.body)}catch(c){throw c instanceof jsCommon.GenericError?c:new jsCommon.ParseError(c)}}toString(){return this.id}};var R=class{static{a(this,"Client");}name;id;options;xssi;constructor(e){this.name=e.name,this.id=e.id,this.options=e.options,this.xssi=e.xssi;}request(e,t){throw new jsCommon.UnimplementedError}};function $e(s){let e={};return e[jsCommon.HttpContentType.PROTOBUF]={request:jsCommon.HttpContentType.PROTOBUF,response:jsCommon.HttpContentType.PROTOBUF,encode:t=>s.requestType.encode(t).finish(),decode:t=>s.responseType.decode(t)},e[jsCommon.HttpContentType.PROTOBUFFER]={request:jsCommon.HttpContentType.PROTOBUFFER,response:jsCommon.HttpContentType.PROTOBUFFER,encode:t=>s.requestType.encode(t).finish(),decode:t=>s.responseType.decode(t)},e[jsCommon.HttpContentType.JSON]={request:jsCommon.HttpContentType.JSON,response:jsCommon.HttpContentType.JSON,encode:t=>jsCommon.Json.encode(s.requestType.toJSON(t)),decode:t=>s.responseType.fromJSON(jsCommon.Json.decode(t))},e}a($e,"transportFrom");var O=class{static{a(this,"ProtoServiceDefinition");}constructor(){}static methodsFrom(e){let t={};for(let r in e.methods){let i=e.methods[r],n=descriptor.MethodOptions.getExtension(i.options,annotations.http);if(!n)throw new jsCommon.UnsupportedError(`Service method ${i.name} has no 'httpRule'`);let o={name:i.name,scopes:[],transport:$e(i)};n.get?(o.method=jsCommon.HttpMethod.GET,o.path=n.get):n.put?(o.method=jsCommon.HttpMethod.PUT,o.path=n.put):n.post?(o.method=jsCommon.HttpMethod.POST,o.path=n.post):n.delete?(o.method=jsCommon.HttpMethod.DELETE,o.path=n.delete):n.patch?(o.method=jsCommon.HttpMethod.PATCH,o.path=n.patch):n.custom&&(o.method=n.custom.kind,o.path=n.custom.path),t[r]=o;}return t}};var C=class{static{a(this,"ServiceFactory");}static installMethod(e,t,r,i){t[r]=function(n){this.preflight();let o=`${e.id}->${i.name}`,d=i.path;if(d.startsWith("/")&&(d=d.substring(1)),!i.transport)throw new jsCommon.UnsupportedError(`Service method '${o}' has no transport`);let c=i.transport[this.transport];if(!c)throw new jsCommon.UnsupportedError(`Service method '${o}' has no transport '${this.transport}'`);let l=i.scopes;this.scopes&&(l?l=l.concat(this.scopes):l=this.scopes);let u=this.transact.bind(this,i.method,this.getFullPath(d),c,c.request??this.transport);return t[r]=u,u(n)};}static create(e,t){let r=class extends A{static{a(this,"GeneratedService");}},i=r.prototype;for(let[n,o]of jsCommon.KV.entries(t))this.installMethod(e,i,n,o);return r}};var N=class{static{a(this,"ServiceProvider");}clients;transports;services;constructor(){this.clients=new Map,this.transports=new Map,this.services=new Map;}methodsFrom(e){let t={};for(let r of e){let i=_case.camel(r.name),n={};for(let o of r.transport){let d=this.transports.get(o);d||(d=Q.from(o)),d&&(n[o]=d);}t[i]={name:r.name,scopes:r.scopes,path:r.path,method:r.method,body:r.body,transport:n};}return t}registerClients(e){for(let t of e){let r=t.implementation??R;delete t.implementation;let i=new r(t);this.clients.set(i.id,i);}}registerServices(e){for(let t of e){let r={};if(t.implementation){if(t.methods)throw new jsCommon.InvalidArgumentError("Service cannot have both 'implementation' and 'methods'");let i=t.implementation;i.protoOverREST?r=O.methodsFrom(i.protoOverREST):i.gRPC&&(r=O.methodsFrom(i.gRPC)),delete t.implementation;}else t.methods&&(r=this.methodsFrom(t.methods));this.services.set(t.id,{definition:t,methods:r,implementation:C.create(t,r)});}}registerTransports(e){for(let t of e)this.transports.set(t.id,t.implementation);}create(e,t){let r=this.services.get(e);if(!r)throw new jsCommon.NotFoundError(`Service '${e}' not found`);let i=this.clients.get(r.definition.client);if(!i)throw new jsCommon.NotFoundError(`Client '${r.definition.client}' not found`);return new r.implementation(r.definition,i,r.methods,t)}},Wt=new N;var Zt={parse(s){return s.split(" ")},stringify(s){return s.join(" ")}},g=class extends jsCommon.GenericError{static{a(this,"OAuthError");}constructor(e,t="Error authenticating with service"){super(e??"Generic OAuth error",t);}},T=class extends g{static{a(this,"InvalidCredentialsError");}constructor(e){super(e??"Invalid credentials");}},X=class extends g{static{a(this,"UserDeniedError");}constructor(e){super(e??"Authentication rejected by user");}},Z=class extends g{static{a(this,"UnrecognizedIDClientError");}constructor(e){super(e??"Unrecognized client id");}},ee=class extends g{static{a(this,"UnauthorizedClientError");}constructor(e){super(e??"Unauthorized client");}},te=class extends g{static{a(this,"InvalidScopeError");}constructor(e){super(e??"Invalid scope");}};var re=class{static{a(this,"OAuthIssuer");}name;id;constructor(e,t){this.name=e,this.id=t;}toString(e){return e.type?`${e.type} ${e.secret}`:e.secret}};var b=class{static{a(this,"Credentials");}},se=class extends b{static{a(this,"ApiKey");}key;constructor(e){super(),this.key=e;}};var E=class extends b{static{a(this,"Token");}id;issuer;expire;type;secret;metadata;constructor(e){super(),this.id=e.id,this.issuer=e.issuer,this.expire=e.expire,this.type=e.type,this.secret=e.secret,this.metadata=e.metadata;}get expired(){return this.expire===void 0?!1:Date.now()>this.expire*1e3}toString(){return this.issuer.toString(this)}},K=class extends E{static{a(this,"RefreshToken");}constructor(e){super(e);}},h=class extends E{static{a(this,"AccessToken");}client;scopes;refresher;refreshPromise;constructor(e){super(e),this.client=e.client,this.scopes=e.scopes,this.refresher=e.refresher;}assignToken(e){this.expire=e.expire,this.type=e.type,this.secret=e.secret,this.scopes=e.scopes,this.metadata=e.metadata;}async doRefresh(){if(!this.id)return this.assignToken(await this.issuer.refresh(this,this.refresher));await k.synchronized(this,async e=>{e&&e.secret!=this.secret?this.assignToken(e):this.assignToken(await this.issuer.refresh(this,this.refresher));});}refresh(){if(!this.refresher)throw new T("No refresh token");return this.refreshPromise||(this.refreshPromise=this.doRefresh(),this.refreshPromise.finally(()=>{this.refreshPromise=void 0;})),this.refreshPromise}revoke(){return this.issuer.revoke(this)}get meta(){return this.metadata??this.refresher?.metadata}};var M=class extends jsCommon.GenericError{static{a(this,"DatabaseError");}constructor(e){super(e,"Database error");}};function y(s){let e={id:s.id,issuer:s.issuer.id,type:s.type,secret:s.secret,expire:s.expire,metadata:s.metadata};return s instanceof h&&(e.client=s.client,e.scopes=s.scopes,e.refresher=s.refresher?.id),e}a(y,"tokenToJson");function ne(s){return new K({id:s.id,issuer:w.getIssuer(s.issuer),type:s.type,secret:s.secret,expire:s.expire,metadata:s.metadata})}a(ne,"createRefreshToken");function U(s,e){return new h({id:s.id,issuer:w.getIssuer(s.issuer),type:s.type,secret:s.secret,expire:s.expire,metadata:s.metadata,client:s.client,scopes:s.scopes,refresher:e})}a(U,"createAccessToken");var I=class{static{a(this,"StorageMedium");}},$=class extends I{static{a(this,"MemoryStorageMedium");}keys=new Map;refreshTokens=new Map;accessTokens=new Map;locks=new Map;setKey(e,t){this.keys.set(e,t);}getKey(e){return this.keys.get(e)}deleteKey(e){this.keys.delete(e);}addToken(e){e instanceof h?this.accessTokens.set(e.id,e):this.refreshTokens.set(e.id,e);}updateToken(e){}deleteToken(e){e instanceof h?this.accessTokens.delete(e.id):this.refreshTokens.delete(e.id);}getRefreshToken(e){return this.refreshTokens.get(e)}getAccessToken(e){return this.accessTokens.get(e)}async synchronized(e,t){let r=!1,i=new mongodb.ObjectId().toHexString(),n,o;for(let c=0;c<15&&(n=Date.now(),o=this.accessTokens.get(e.id),!(!o||o.secret!=e.secret));c++){let l=this.locks.get(e.id);if(!l||l.date<=n-2e4){l={id:i,date:n},this.locks.set(e.id,l),r=!0;break}await jsCommon.Promises.resolveAfter(2e3);}let d;try{await t(o);}catch(c){d=c;}if(r||!o){let c=this.locks.get(e.id),l=c?.id==i;(l||!c)&&(l&&this.locks.delete(e.id),this.accessTokens.set(e.id,e));}if(d)throw d}listAllKeys(){return this.keys}listAllRefreshTokens(){return Array.from(this.refreshTokens.values()).map(e=>y(e))}listAllAccessTokens(){return Array.from(this.accessTokens.values()).map(e=>y(e))}},F=class extends I{static{a(this,"DatabaseStorageMedium");}url;db;client;keys;refreshTokens;accessTokens;ready;shouldClose=!1;operations=0;closeTimeout;constructor(e,t){super(),this.url=e,this.db=t,this.closeTimeout=new jsCommon.Timer({initialTimeout:1e4},()=>this.destroy());}createIndex(e,t){let r=[];for(let[i,n]of jsCommon.KV.entries(t)){let o;typeof n=="object"&&(n.unique&&(o={unique:!0}),n=n.direction),r.push(e.createIndex({[i]:n},o));}return Promise.all(r)}async initialize(){this.client=new mongodb.MongoClient(this.url);try{await this.client.connect();}catch(t){throw this.close(),new jsCommon.UnavailableError(t)}let e=this.client.db(this.db);this.keys=e.collection("keys"),this.refreshTokens=e.collection("refreshTokens"),this.accessTokens=e.collection("accessTokens");try{await Promise.all([this.createIndex(this.keys,{key:{direction:1,unique:!0}}),this.createIndex(this.refreshTokens,{id:{direction:1,unique:!0}}),this.createIndex(this.accessTokens,{id:{direction:1,unique:!0},refresher:1})]);}catch(t){throw this.close(),new M(t)}this.closeTimeout.start();}close(){this.ready=void 0,this.shouldClose=!1,this.closeTimeout.stop(),this.client.close();}destroy(){this.operations?this.shouldClose=!0:this.close();}async setup(){return this.ready?(this.closeTimeout.start(),this.shouldClose=!1):this.ready=this.initialize(),this.ready}runDbOp(e){this.operations++;let t=this.setup().then(e).catch(r=>{throw new M(r)});return t.catch(r=>{console.error(`Database operation failed: ${r.stack??r.message}`);}).finally(()=>{this.operations--,!this.operations&&this.shouldClose&&this.close();}),t}setKey(e,t){return this.runDbOp(()=>this.keys.updateOne({key:e},{$set:{key:e,value:t}},{upsert:!0}))}getKey(e){return this.runDbOp(async()=>(await this.keys.findOne({key:e}))?.value)}deleteKey(e){return this.runDbOp(()=>this.keys.deleteOne({key:e}))}addToken(e){let t=y(e);return this.runDbOp(()=>(e instanceof h?this.accessTokens:this.refreshTokens).insertOne(t))}updateToken(e){let t=y(e);return this.runDbOp(()=>(e instanceof h?this.accessTokens:this.refreshTokens).updateOne({id:t.id},{$set:t}))}deleteToken(e){return this.runDbOp(()=>(e instanceof h?this.accessTokens:this.refreshTokens).deleteOne({id:e.id}))}getRefreshToken(e){return this.runDbOp(async()=>{let t=await this.refreshTokens.findOne({id:e});if(t)return ne(t)})}getAccessToken(e){return this.runDbOp(async()=>{let t=await this.accessTokens.findOne({id:e});if(!t)return;let r;return t.refresher&&(r=await this.getRefreshToken(t.refresher)),U(t,r)})}async synchronized(e,t){await this.setup();let r=!1,i=new mongodb.ObjectId,n,o;for(let c=0;c<15;c++){n=Date.now();try{if((await this.accessTokens.updateOne({id:e.id,secret:e.secret,$or:[{lockDate:{$lte:n-2e4}},{lockId:null}]},{$set:{lockId:i,lockDate:n}})).matchedCount){r=!0;break}let u=await this.accessTokens.findOne({id:e.id});if(!u||(o=U(u),o.secret!=e.secret))break;await jsCommon.Promises.resolveAfter(2e3);}catch(l){console.error(`Failed to acquire lock: ${l.stack??l.message}`);break}}let d;try{await t(o);}catch(c){d=c;}if(r||!o){let c;r?c={lockId:i,lockDate:n}:c={lockId:null,lockDate:null};try{await this.accessTokens.updateOne({id:e.id,...c},{$set:{...y(e),lockDate:void 0,lockId:void 0}});}catch(l){console.error(`Failed to release lock: ${l.stack??l.message}`);}}if(d)throw d}listAllKeys(){return this.runDbOp(async()=>{let e=await this.keys.find().toArray(),t=new Map;for(let r of e)t.set(r.key,r.value);return t})}listAllRefreshTokens(){return this.runDbOp(()=>this.refreshTokens.find().toArray())}listAllAccessTokens(){return this.runDbOp(()=>this.accessTokens.find().toArray())}},z=class extends ${static{a(this,"FileStorageMedium");}config;saving;queuedSave=!1;constructor(e){super();try{this.config=p.loadConfigSync(e);}catch(r){if(!(r instanceof jsCommon.NotFoundError))throw r;this.config=new p(e,{});}let t=this.config.get("keys");t&&(this.keys=jsCommon.KV.toMap(t)),this.loadTokens(this.refreshTokens,!0),this.loadTokens(this.accessTokens,!1);}loadTokens(e,t){let r=this.config.get(t?"refreshTokens":"accessTokens");if(r)for(let i of r){let n;i.refresher&&(n=this.refreshTokens.get(i.refresher));let o=t?ne(i):U(i,n);e.set(o.id,o);}}saveImpl(){let e=[],t=[];for(let[r,i]of this.refreshTokens)e.push(y(i));for(let[r,i]of this.accessTokens)t.push(y(i));return this.config.set("keys",jsCommon.KV.fromMap(this.keys)),this.config.set("refreshTokens",e),this.config.set("accessTokens",t),this.config.save()}async save(){if(this.saving){this.queuedSave=!0;return}do{this.queuedSave=!1,this.saving=this.saveImpl();try{await this.saving;}catch(e){console.error(`Failed to save credentials: ${e.stack??e.message}`);}}while(this.queuedSave);this.saving=void 0;}setKey(e,t){super.setKey(e,t),this.save();}getKey(e){return super.getKey(e)}deleteKey(e){super.deleteKey(e);}addToken(e){super.addToken(e),this.save();}updateToken(e){super.updateToken(e),this.save();}deleteToken(e){super.deleteToken(e),this.save();}getRefreshToken(e){return super.getRefreshToken(e)}getAccessToken(e){return super.getAccessToken(e)}},k=class{static{a(this,"CredentialStore");}static DatabaseStorageMedium=F;static medium;constructor(){}static initialize(){if(this.medium)return;let e=p.get("mongodb/url"),t=p.get("credentials/database");if(e&&t){this.medium=new F(e,t);return}let r=p.get("credentials/file");if(r){this.medium=new z(r);return}console.warn("No database to store credentials, using memory"),this.medium=new $;}static setKey(e,t){return this.initialize(),this.medium.setKey(e,t)}static getKey(e){return this.initialize(),this.medium.getKey(e)}static deleteKey(e){return this.initialize(),this.medium.deleteKey(e)}static addToken(e){let t=(async()=>{if(this.initialize(),e.id)throw new jsCommon.ExistsError("Token already added");e.id=new mongodb.ObjectId().toHexString(),e instanceof h&&e.refresher&&!e.refresher.id&&await this.addToken(e.refresher),await this.medium.addToken(e);})();return t.catch(()=>{}),t}static updateToken(e){if(this.initialize(),!e.id)throw new jsCommon.NotFoundError("Token not added");return this.medium.updateToken(e)}static deleteToken(e){return (async()=>{if(this.initialize(),!e.id)throw new jsCommon.NotFoundError("Token not added");await this.medium.deleteToken(e),e.id=void 0;})()}static async getRefreshToken(e){this.initialize();let t=await this.medium.getRefreshToken(e);if(!t)throw new jsCommon.NotFoundError(`Refresh token with id '${e}' not found`);return t}static async getAccessToken(e){this.initialize();let t=await this.medium.getAccessToken(e);if(!t)throw new jsCommon.NotFoundError(`Access token with id '${e}' not found`);return t}static synchronized(e,t){if(!e.id)throw new jsCommon.NotFoundError("Token not added");return this.initialize(),this.medium.synchronized(e,t)}};var J=class{static{a(this,"OAuthProvider");}issuers;clients;constructor(){this.issuers=new Map,this.clients=new Map;}registerIssuers(e){for(let t of e){let r=t.implementation,i=new r(t.name,t.id);this.issuers.set(i.id,i);}}registerClients(e){for(let t of e)this.clients.set(t.id,t);}getIssuer(e){let t=this.issuers.get(e);if(!t)throw new jsCommon.NotFoundError(`Issuer '${e}' not found`);return t}getClient(e){let t=this.clients.get(e);if(!t)throw new jsCommon.NotFoundError(`Client '${e}' not found`);return t}},w=new J;var Be=Oe("electron");function br(s,e){let t=child_process.spawn(Be,[s],{stdio:["ipc",process.stdin,process.stdout]}),r=[],i=!1,n=a(l=>{switch(l.event){case"ready":e&&t.send({event:"options",data:e}),t.send({event:"start"});break;case"output":r.push(l.data);break}},"message"),o=a(l=>{i=!0,t.killed||t.kill(l);},"signalHandler"),d=o.bind("SIGINT"),c=o.bind("SIGTERM");return process.on("SIGINT",d),process.on("SIGTERM",c),new Promise((l,u)=>{let we=a((V,Se)=>{process.off("SIGINT",d),process.off("SIGTERM",c),!i&&(V===0?l(r):u(V!==null?new jsCommon.GenericError(`Child process exited with code ${V}`):new jsCommon.GenericError(`Child process exited with signal ${Se}`)));},"close");t.on("message",n),t.on("close",we);})}a(br,"launch");var ce=class{static{a(this,"OAuthTools");}static optionsFromCmdLine(){let e=je__default.default(helpers.hideBin(process.argv)).parseSync(),t=e._.join(" "),r=e.scope;return typeof r=="string"&&(r=[r]),p.use(e.config),delete e.$0,delete e._,delete e.scope,delete e.config,{client:t,scopes:r,args:e}}static async login(e=this.optionsFromCmdLine()){let{scopes:t,args:r}=e,i=w.getClient(e.client),o=await w.getIssuer(i.config.issuer).perform(i,t,r);return await k.addToken(o),o}};var Ge={};var le=class{static{a(this,"HttpClients");}constructor(){}static makeError(e,t,r){switch(r&&(t=t?`${r}: ${t}`:r),t||(t=`HTTP ${e.status}: ${e.statusText}`),e.status){case 400:case 405:case 413:case 431:return new jsCommon.InvalidArgumentError(t);case 401:return new T(t);case 403:return new jsCommon.PermissionDeniedError(t);case 404:return new jsCommon.NotFoundError(t);case 412:case 428:return new jsCommon.PreconditionFailedError(t);case 418:return new jsCommon.UnsupportedError(t);case 429:return new jsCommon.RateLimitedError(t);case 500:return new jsCommon.InternalServerError(t);case 501:return new jsCommon.UnimplementedError(t);case 502:return new jsCommon.NetworkError(t);case 503:return new jsCommon.UnavailableError(t);case 504:return new jsCommon.TimedOutError(t);case 505:return new jsCommon.UnsupportedError(t)}throw e.status>=400&&e.status<500?new jsCommon.ClientError(t):e.status>=500&&e.status<600?new jsCommon.ServerError(t):new jsCommon.HttpError(t)}};var pe={request:jsCommon.HttpContentType.OCTET_STREAM,response:jsCommon.HttpContentType.OCTET_STREAM,encode:s=>s,decode:s=>s};var me={request:jsCommon.HttpContentType.JSON,response:jsCommon.HttpContentType.JSON,encode:s=>jsCommon.Json.encode(s),decode:s=>jsCommon.Json.decode(s)};var Te={request:jsCommon.HttpContentType.URLFORM,response:jsCommon.HttpContentType.URLFORM,encode:s=>jsCommon.URLParams.toString(s),decode:s=>jsCommon.URLParams.toKV(s.toString())};var Q={from(s){switch(s){case jsCommon.HttpContentType.JSON:return me;case jsCommon.HttpContentType.URLFORM:return Te;case jsCommon.HttpContentType.OCTET_STREAM:return pe}}};var P=class extends jsCommon.Request{static{a(this,"ApiRequest");}url;constructor(e){super(),this.url=new jsCommon.URLBuilder(e);}get https(){return this.url.scheme=="https"}execute(){return super.execute(this.url.href)}};var lt={};var p=class s{static{a(this,"Config");}static config;path;data;constructor(e,t){this.path=e,this.data=t;}static async read(e){let t;try{t=await promises.readFile(e,"utf8");}catch(r){throw r.code=="ENOENT"?new jsCommon.NotFoundError(`File not found: ${e}`):r}return jsCommon.Yaml.decode(t)}static readSync(e){let t;try{t=fs.readFileSync(e,"utf8");}catch(r){throw r.code=="ENOENT"?new jsCommon.NotFoundError(`File not found: ${e}`):r}return jsCommon.Yaml.decode(t)}static async write(e,t){await promises.writeFile(e,t===void 0?"":jsCommon.Yaml.encode(t));}static async loadConfig(e){return new s(e,await this.read(e))}static loadConfigSync(e){return new s(e,this.readSync(e))}static use(e){this.config=this.loadConfigSync(e??"mosaic_config.yaml");}static get(e){return this.config||this.use(),this.config?.get(e)}get(e){let t=this.data,r=e.split("/");for(;r.length;){if(t===void 0)return;if(typeof t!="object"||t===null)throw new jsCommon.ParseError(`Could not read config '${e}'`);t=t[r.shift()];}return t}set(e,t){let r=this.data,i=e.split("/");for(r==null&&(this.data=r={});i.length>1;){let n=i.shift();if(r[n]===void 0||r[n]===null){r=r[n]={};continue}if(typeof r[n]!="object")throw new jsCommon.ParseError(`Could not set config '${e}'`);r=r[n];}r[i.shift()]=t;}save(){return s.write(this.path,this.data)}};

exports.AccessToken = h;
exports.ApiKey = se;
exports.ApiRequest = P;
exports.Client = R;
exports.ClientStorage = lt;
exports.Config = p;
exports.CredentialStore = k;
exports.Credentials = b;
exports.DatabaseError = M;
exports.DefaultOAuthProvider = w;
exports.DefaultServiceProvider = Wt;
exports.HttpClients = le;
exports.InvalidCredentialsError = T;
exports.InvalidScopeError = te;
exports.OAuthError = g;
exports.OAuthIssuer = re;
exports.OAuthProvider = J;
exports.OAuthStorage = Ge;
exports.OAuthTools = ce;
exports.RefreshToken = K;
exports.Scopes = Zt;
exports.Service = A;
exports.ServiceProvider = N;
exports.Token = E;
exports.Transport = Q;
exports.UnauthorizedClientError = ee;
exports.UnrecognizedIDClientError = Z;
exports.UserDeniedError = X;
exports.launch = br;
