'use strict';

var jsCommon = require('js-common');
require('protobuf-ts/protos/google/protobuf/descriptor');
require('protobuf-ts/protos/google/api/annotations');
require('case');
var mongodb = require('mongodb');
require('child_process');
var helpers = require('yargs/helpers');
var yargs2 = require('yargs');
var promises = require('fs/promises');
var fs = require('fs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var yargs2__default = /*#__PURE__*/_interopDefault(yargs2);

var __require=(x=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(x,{get:(a,b)=>(typeof require<"u"?require:a)[b]}):x)(function(x){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+x+'" is not supported')});var OAuthError=class extends jsCommon.GenericError{constructor(arg,defaultSimpleMessage="Error authenticating with service"){super(arg??"Generic OAuth error",defaultSimpleMessage);}},InvalidCredentialsError=class extends OAuthError{constructor(arg){super(arg??"Invalid credentials");}};var Credentials2=class{};var Token=class extends Credentials2{id;issuer;expire;type;secret;metadata;constructor(args){super(),this.id=args.id,this.issuer=args.issuer,this.expire=args.expire,this.type=args.type,this.secret=args.secret,this.metadata=args.metadata;}get expired(){return this.expire===void 0?!1:Date.now()>this.expire*1e3}toString(){return this.issuer.toString(this)}},RefreshToken=class extends Token{constructor(args){super(args);}},AccessToken=class extends Token{client;scopes;refresher;refreshPromise;constructor(args){super(args),this.client=args.client,this.scopes=args.scopes,this.refresher=args.refresher;}assignToken(token){this.expire=token.expire,this.type=token.type,this.secret=token.secret,this.scopes=token.scopes,this.metadata=token.metadata;}async doRefresh(){if(!this.id)return this.assignToken(await this.issuer.refresh(this,this.refresher));await CredentialStore.synchronized(this,async token=>{token&&token.secret!=this.secret?this.assignToken(token):this.assignToken(await this.issuer.refresh(this,this.refresher));});}refresh(){if(!this.refresher)throw new InvalidCredentialsError("No refresh token");return this.refreshPromise||(this.refreshPromise=this.doRefresh(),this.refreshPromise.finally(()=>{this.refreshPromise=void 0;})),this.refreshPromise}revoke(){return this.issuer.revoke(this)}get meta(){return this.metadata??this.refresher?.metadata}};var DatabaseError=class extends jsCommon.GenericError{constructor(arg){super(arg,"Database error");}};function tokenToJson(token){let json={id:token.id,issuer:token.issuer.id,type:token.type,secret:token.secret,expire:token.expire,metadata:token.metadata};return token instanceof AccessToken&&(json.client=token.client,json.scopes=token.scopes,json.refresher=token.refresher?.id),json}function createRefreshToken(token){return new RefreshToken({id:token.id,issuer:DefaultOAuthProvider.getIssuer(token.issuer),type:token.type,secret:token.secret,expire:token.expire,metadata:token.metadata})}function createAccessToken(token,refresher){return new AccessToken({id:token.id,issuer:DefaultOAuthProvider.getIssuer(token.issuer),type:token.type,secret:token.secret,expire:token.expire,metadata:token.metadata,client:token.client,scopes:token.scopes,refresher})}var StorageMedium=class{},MemoryStorageMedium=class extends StorageMedium{keys=new Map;refreshTokens=new Map;accessTokens=new Map;locks=new Map;setKey(key,value){this.keys.set(key,value);}getKey(key){return this.keys.get(key)}deleteKey(key){this.keys.delete(key);}addToken(token){token instanceof AccessToken?this.accessTokens.set(token.id,token):this.refreshTokens.set(token.id,token);}updateToken(token){}deleteToken(token){token instanceof AccessToken?this.accessTokens.delete(token.id):this.refreshTokens.delete(token.id);}getRefreshToken(id){return this.refreshTokens.get(id)}getAccessToken(id){return this.accessTokens.get(id)}async synchronized(access,callback){let lockSuccess=!1,lockId=new mongodb.ObjectId().toHexString(),now,token;for(let i=0;i<15&&(now=Date.now(),token=this.accessTokens.get(access.id),!(!token||token.secret!=access.secret));i++){let lock=this.locks.get(access.id);if(!lock||lock.date<=now-2e4){lock={id:lockId,date:now},this.locks.set(access.id,lock),lockSuccess=!0;break}await jsCommon.Promises.resolveAfter(2e3);}let error;try{await callback(token);}catch(e){error=e;}if(lockSuccess||!token){let lock=this.locks.get(access.id),holding=lock?.id==lockId;(holding||!lock)&&(holding&&this.locks.delete(access.id),this.accessTokens.set(access.id,access));}if(error)throw error}listAllKeys(){return this.keys}listAllRefreshTokens(){return Array.from(this.refreshTokens.values()).map(token=>tokenToJson(token))}listAllAccessTokens(){return Array.from(this.accessTokens.values()).map(token=>tokenToJson(token))}},DatabaseStorageMedium=class extends StorageMedium{url;db;client;keys;refreshTokens;accessTokens;ready;shouldClose=!1;operations=0;closeTimeout;constructor(url,db){super(),this.url=url,this.db=db,this.closeTimeout=new jsCommon.Timer({initialTimeout:1e4},()=>this.destroy());}createIndex(collection,fields){let promises=[];for(let[key,value]of jsCommon.KV.entries(fields)){let options;typeof value=="object"&&(value.unique&&(options={unique:!0}),value=value.direction),promises.push(collection.createIndex({[key]:value},options));}return Promise.all(promises)}async initialize(){this.client=new mongodb.MongoClient(this.url);try{await this.client.connect();}catch(e){throw this.close(),new jsCommon.UnavailableError(e)}let db=this.client.db(this.db);this.keys=db.collection("keys"),this.refreshTokens=db.collection("refreshTokens"),this.accessTokens=db.collection("accessTokens");try{await Promise.all([this.createIndex(this.keys,{key:{direction:1,unique:!0}}),this.createIndex(this.refreshTokens,{id:{direction:1,unique:!0}}),this.createIndex(this.accessTokens,{id:{direction:1,unique:!0},refresher:1})]);}catch(e){throw this.close(),new DatabaseError(e)}this.closeTimeout.start();}close(){this.ready=void 0,this.shouldClose=!1,this.closeTimeout.stop(),this.client.close();}destroy(){this.operations?this.shouldClose=!0:this.close();}async setup(){return this.ready?(this.closeTimeout.start(),this.shouldClose=!1):this.ready=this.initialize(),this.ready}runDbOp(fn){this.operations++;let promise=this.setup().then(fn).catch(e=>{throw new DatabaseError(e)});return promise.catch(e=>{console.error(`Database operation failed: ${e.stack??e.message}`);}).finally(()=>{this.operations--,!this.operations&&this.shouldClose&&this.close();}),promise}setKey(key,value){return this.runDbOp(()=>this.keys.updateOne({key},{$set:{key,value}},{upsert:!0}))}getKey(key){return this.runDbOp(async()=>(await this.keys.findOne({key}))?.value)}deleteKey(key){return this.runDbOp(()=>this.keys.deleteOne({key}))}addToken(token){let json=tokenToJson(token);return this.runDbOp(()=>(token instanceof AccessToken?this.accessTokens:this.refreshTokens).insertOne(json))}updateToken(token){let json=tokenToJson(token);return this.runDbOp(()=>(token instanceof AccessToken?this.accessTokens:this.refreshTokens).updateOne({id:json.id},{$set:json}))}deleteToken(token){return this.runDbOp(()=>(token instanceof AccessToken?this.accessTokens:this.refreshTokens).deleteOne({id:token.id}))}getRefreshToken(id){return this.runDbOp(async()=>{let token=await this.refreshTokens.findOne({id});if(token)return createRefreshToken(token)})}getAccessToken(id){return this.runDbOp(async()=>{let token=await this.accessTokens.findOne({id});if(!token)return;let refresher;return token.refresher&&(refresher=await this.getRefreshToken(token.refresher)),createAccessToken(token,refresher)})}async synchronized(token,callback){await this.setup();let lockSuccess=!1,lockId=new mongodb.ObjectId,now,dbToken;for(let i=0;i<15;i++){now=Date.now();try{if((await this.accessTokens.updateOne({id:token.id,secret:token.secret,$or:[{lockDate:{$lte:now-2e4}},{lockId:null}]},{$set:{lockId,lockDate:now}})).matchedCount){lockSuccess=!0;break}let doc=await this.accessTokens.findOne({id:token.id});if(!doc||(dbToken=createAccessToken(doc),dbToken.secret!=token.secret))break;await jsCommon.Promises.resolveAfter(2e3);}catch(e){console.error(`Failed to acquire lock: ${e.stack??e.message}`);break}}let error;try{await callback(dbToken);}catch(e){error=e;}if(lockSuccess||!dbToken){let query;lockSuccess?query={lockId,lockDate:now}:query={lockId:null,lockDate:null};try{await this.accessTokens.updateOne({id:token.id,...query},{$set:{...tokenToJson(token),lockDate:void 0,lockId:void 0}});}catch(e){console.error(`Failed to release lock: ${e.stack??e.message}`);}}if(error)throw error}listAllKeys(){return this.runDbOp(async()=>{let kvs=await this.keys.find().toArray(),map=new Map;for(let kv of kvs)map.set(kv.key,kv.value);return map})}listAllRefreshTokens(){return this.runDbOp(()=>this.refreshTokens.find().toArray())}listAllAccessTokens(){return this.runDbOp(()=>this.accessTokens.find().toArray())}},FileStorageMedium=class extends MemoryStorageMedium{config;saving;queuedSave=!1;constructor(filename){super();try{this.config=Config.loadConfigSync(filename);}catch(e){if(!(e instanceof jsCommon.NotFoundError))throw e;this.config=new Config(filename,{});}let keys=this.config.get("keys");keys&&(this.keys=jsCommon.KV.toMap(keys)),this.loadTokens(this.refreshTokens,!0),this.loadTokens(this.accessTokens,!1);}loadTokens(map,refresh){let tokens=this.config.get(refresh?"refreshTokens":"accessTokens");if(tokens)for(let storageToken of tokens){let refresher;storageToken.refresher&&(refresher=this.refreshTokens.get(storageToken.refresher));let token=refresh?createRefreshToken(storageToken):createAccessToken(storageToken,refresher);map.set(token.id,token);}}saveImpl(){let refresh=[],access=[];for(let[_,token]of this.refreshTokens)refresh.push(tokenToJson(token));for(let[_,token]of this.accessTokens)access.push(tokenToJson(token));return this.config.set("keys",jsCommon.KV.fromMap(this.keys)),this.config.set("refreshTokens",refresh),this.config.set("accessTokens",access),this.config.save()}async save(){if(this.saving){this.queuedSave=!0;return}do{this.queuedSave=!1,this.saving=this.saveImpl();try{await this.saving;}catch(e){console.error(`Failed to save credentials: ${e.stack??e.message}`);}}while(this.queuedSave);this.saving=void 0;}setKey(key,value){super.setKey(key,value),this.save();}getKey(key){return super.getKey(key)}deleteKey(key){super.deleteKey(key);}addToken(token){super.addToken(token),this.save();}updateToken(token){super.updateToken(token),this.save();}deleteToken(token){super.deleteToken(token),this.save();}getRefreshToken(id){return super.getRefreshToken(id)}getAccessToken(id){return super.getAccessToken(id)}},CredentialStore=class{static DatabaseStorageMedium=DatabaseStorageMedium;static medium;constructor(){}static initialize(){if(this.medium)return;let url=Config.get("mongodb/url"),dbName=Config.get("credentials/database");if(url&&dbName){this.medium=new DatabaseStorageMedium(url,dbName);return}let file=Config.get("credentials/file");if(file){this.medium=new FileStorageMedium(file);return}console.warn("No database to store credentials, using memory"),this.medium=new MemoryStorageMedium;}static setKey(key,value){return this.initialize(),this.medium.setKey(key,value)}static getKey(key){return this.initialize(),this.medium.getKey(key)}static deleteKey(key){return this.initialize(),this.medium.deleteKey(key)}static addToken(token){let promise=(async()=>{if(this.initialize(),token.id)throw new jsCommon.ExistsError("Token already added");token.id=new mongodb.ObjectId().toHexString(),token instanceof AccessToken&&token.refresher&&!token.refresher.id&&await this.addToken(token.refresher),await this.medium.addToken(token);})();return promise.catch(()=>{}),promise}static updateToken(token){if(this.initialize(),!token.id)throw new jsCommon.NotFoundError("Token not added");return this.medium.updateToken(token)}static deleteToken(token){return (async()=>{if(this.initialize(),!token.id)throw new jsCommon.NotFoundError("Token not added");await this.medium.deleteToken(token),token.id=void 0;})()}static async getRefreshToken(id){this.initialize();let token=await this.medium.getRefreshToken(id);if(!token)throw new jsCommon.NotFoundError(`Refresh token with id '${id}' not found`);return token}static async getAccessToken(id){this.initialize();let token=await this.medium.getAccessToken(id);if(!token)throw new jsCommon.NotFoundError(`Access token with id '${id}' not found`);return token}static synchronized(token,callback){if(!token.id)throw new jsCommon.NotFoundError("Token not added");return this.initialize(),this.medium.synchronized(token,callback)}};var OAuthProvider=class{issuers;clients;constructor(){this.issuers=new Map,this.clients=new Map;}registerIssuers(issuers){for(let issuer of issuers){let impl=issuer.implementation,instance=new impl(issuer.name,issuer.id);this.issuers.set(instance.id,instance);}}registerClients(clients){for(let client of clients)this.clients.set(client.id,client);}getIssuer(id){let issuer=this.issuers.get(id);if(!issuer)throw new jsCommon.NotFoundError(`Issuer '${id}' not found`);return issuer}getClient(id){let client=this.clients.get(id);if(!client)throw new jsCommon.NotFoundError(`Client '${id}' not found`);return client}},DefaultOAuthProvider=new OAuthProvider;__require("electron");({request:jsCommon.HttpContentType.OCTET_STREAM,response:jsCommon.HttpContentType.OCTET_STREAM,encode:message=>message,decode:message=>message});({request:jsCommon.HttpContentType.JSON,response:jsCommon.HttpContentType.JSON,encode:message=>jsCommon.Json.encode(message),decode:message=>jsCommon.Json.decode(message)});({request:jsCommon.HttpContentType.URLFORM,response:jsCommon.HttpContentType.URLFORM,encode:message=>jsCommon.URLParams.toString(message),decode:message=>jsCommon.URLParams.toKV(message.toString())});var Config=class _Config{static config;path;data;constructor(path,data){this.path=path,this.data=data;}static async read(path){let contents;try{contents=await promises.readFile(path,"utf8");}catch(error){throw error.code=="ENOENT"?new jsCommon.NotFoundError(`File not found: ${path}`):error}return jsCommon.Yaml.decode(contents)}static readSync(path){let contents;try{contents=fs.readFileSync(path,"utf8");}catch(error){throw error.code=="ENOENT"?new jsCommon.NotFoundError(`File not found: ${path}`):error}return jsCommon.Yaml.decode(contents)}static async write(path,data){await promises.writeFile(path,data===void 0?"":jsCommon.Yaml.encode(data));}static async loadConfig(path){return new _Config(path,await this.read(path))}static loadConfigSync(path){return new _Config(path,this.readSync(path))}static use(path){this.config=this.loadConfigSync(path??"mosaic_config.yaml");}static get(path){return this.config||this.use(),this.config?.get(path)}get(path){let root=this.data,split=path.split("/");for(;split.length;){if(root===void 0)return;if(typeof root!="object"||root===null)throw new jsCommon.ParseError(`Could not read config '${path}'`);root=root[split.shift()];}return root}set(path,value){let root=this.data,split=path.split("/");for(root==null&&(this.data=root={});split.length>1;){let name=split.shift();if(root[name]===void 0||root[name]===null){root=root[name]={};continue}if(typeof root[name]!="object")throw new jsCommon.ParseError(`Could not set config '${path}'`);root=root[name];}root[split.shift()]=value;}save(){return _Config.write(this.path,this.data)}};(async function(){let args=yargs2__default.default(helpers.hideBin(process.argv)).parseSync(),input=args._.join(" ")||"credentials.yaml";Config.use(args.config);let credentials=Config.loadConfigSync(input),url=Config.get("mongodb/url"),dbName=Config.get("credentials/database");if(!url||!dbName)throw new jsCommon.InvalidArgumentError("No db to import to. Please set the mongodb/url and credentials/database keys in the config");let database=new CredentialStore.DatabaseStorageMedium(url,dbName);await database.setup();let totalKeys=0;for(let[key,value]of jsCommon.KV.entries(credentials.get("keys"))){let existing=await database.keys.findOne({key});totalKeys++,existing?.value!=value&&(existing&&console.warn(`Overwriting existing value for ${key}: ${existing.value} -> ${value}`),await database.keys.updateOne({key},{$set:{key,value}},{upsert:!0}));}let totalTokens=0;for(let token of credentials.get("refreshTokens"))await database.refreshTokens.updateOne({id:token.id},{$set:token},{upsert:!0}),totalTokens++;for(let token of credentials.get("accessTokens"))await database.accessTokens.updateOne({id:token.id},{$set:token},{upsert:!0}),totalTokens++;console.log(`Imported ${totalKeys} keys and ${totalTokens} tokens`),database.destroy();})();
//# sourceMappingURL=out.js.map
//# sourceMappingURL=import_credentials.js.map